<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Seoul Eats Map</title>

  <!-- Kakao Maps (services 포함) -->
  <script defer src="https://dapi.kakao.com/v2/maps/sdk.js?appkey=5c2fb05e6765f133c747e1f5a2bdf64d&libraries=services"></script>

  <!-- Supabase JS v2 -->
  <script defer src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

  <style>
    :root{
      --bg: #0b0b0d;
      --panel: #101014;
      --panel2:#0f0f12;
      --line: rgba(255,255,255,.14);
      --muted: rgba(255,255,255,.70);
      --muted2: rgba(255,255,255,.45);
      --txt: rgba(255,255,255,.92);
      --accent: #ffd84a; /* 노란 강조 */
      --danger: #ff4d4d;
      --ok: #61ffb2;

      /* ✅ 그림자 강도 낮춤 */
      --shadow: 0 10px 22px rgba(0,0,0,.35);
      --shadow2: 0 8px 18px rgba(0,0,0,.28);

      --radius: 14px;
      --radius2: 12px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Apple SD Gothic Neo, Noto Sans KR, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    *{ box-sizing:border-box; }
    html, body { height:100%; margin:0; background:var(--bg); color:var(--txt); font-family: var(--sans); }
    #map { position:fixed; inset:0; }

    /* Floating windows */
    .float{
      position: fixed;
      z-index: 30;
      min-width: 260px;
      max-width: min(520px, calc(100vw - 24px));
      background: linear-gradient(180deg, var(--panel), var(--panel2));
      border: 1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow: hidden;
      user-select: none;
    }
    .float .hdr{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding: 10px 12px;
      background: rgba(255,255,255,.03);
      border-bottom: 1px solid var(--line);
      cursor: grab;
    }
    .float .hdr:active{ cursor: grabbing; }
    .float .ttl{
      display:flex; align-items:center; gap:10px;
      font-weight: 700;
      letter-spacing: .2px;
    }
    .pill{
      font-family: var(--mono);
      font-size: 12px;
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid var(--line);
      color: var(--muted);
      background: rgba(0,0,0,.25);
    }
    .float .body{
      padding: 12px;
      user-select: text;
    }

    .btn{
      border: 1px solid var(--line);
      background: rgba(255,255,255,.04);
      color: var(--txt);
      border-radius: 10px;
      padding: 8px 10px;
      cursor: pointer;
      font-weight: 650;
      letter-spacing: .1px;
    }
    .btn:hover{ border-color: rgba(255,255,255,.22); }
    .btn:disabled{ opacity:.45; cursor:not-allowed; }

    .btn.accent{
      border-color: rgba(255,216,74,.45);
      background: rgba(255,216,74,.12);
      color: var(--accent);
    }
    .btn.danger{
      border-color: rgba(255,77,77,.45);
      background: rgba(255,77,77,.10);
      color: #ffd0d0;
    }

    .row{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .col{ display:flex; flex-direction:column; gap:8px; }
    .sp{ height:10px; }
    .muted{ color: var(--muted2); }
    .hl{ color: var(--accent); font-weight: 800; }
    .hr{ height:1px; background: var(--line); margin: 10px 0; }

    label{ font-size: 12px; color: var(--muted2); display:block; margin-bottom: 6px; }
    input, textarea{
      width:100%;
      background: rgba(255,255,255,.04);
      color: var(--txt);
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 10px 10px;
      outline: none;
      font-size: 14px;
    }
    textarea{ min-height: 140px; resize: vertical; }

    .list{ display:flex; flex-direction:column; gap:8px; }
    .card{
      border: 1px solid var(--line);
      background: rgba(255,255,255,.03);
      border-radius: 12px;
      padding: 10px;
    }
    .card .top{ display:flex; justify-content:space-between; gap:10px; align-items:baseline; }
    .meta{ font-family: var(--mono); font-size: 12px; color: var(--muted2); }
    .note{ white-space: pre-wrap; line-height:1.45; }
    .mini-actions{ display:flex; gap:6px; align-items:center; }
    .mini{
      font-family: var(--mono);
      font-size: 12px;
      padding: 6px 8px;
      border-radius: 10px;
      border: 1px solid var(--line);
      background: rgba(0,0,0,.22);
      color: var(--txt);
      cursor:pointer;
    }
    .mini:hover{ border-color: rgba(255,255,255,.22); }

    /* Bottom Dock (검색바) */
    #dock{
      position: fixed;
      z-index: 25;
      left: 50%;
      transform: translateX(-50%);
      bottom: 14px;
      width: min(520px, calc(100vw - 24px));
      border-radius: 18px;
      border: 1px solid var(--line);
      background: rgba(10,10,12,.92);
      box-shadow: var(--shadow2);
      padding: 10px;
      display:flex;
      gap:8px;
      align-items:center;
    }
    #dock input{
      flex: 1;
      border-radius: 14px;
      padding: 10px 12px;
      font-size: 14px;
    }
    #dock .btn{ padding: 10px 10px; border-radius: 14px; }

    /* Toast */
    #toast{
      position: fixed;
      z-index: 999;
      left: 50%;
      transform: translateX(-50%);
      bottom: 86px;
      background: rgba(0,0,0,.78);
      border: 1px solid var(--line);
      color: var(--txt);
      padding: 10px 12px;
      border-radius: 14px;
      box-shadow: var(--shadow2);
      opacity: 0;
      pointer-events:none;
      transition: opacity .18s ease;
      max-width: min(520px, calc(100vw - 24px));
    }
    #toast.show{ opacity: 1; }

    /* Overlays (login/signup/add/account) */
    .overlay{
      position: fixed;
      inset: 0;
      z-index: 100;
      display:none;
      background: rgba(0,0,0,.55);
      align-items:center;
      justify-content:center;
      padding: 16px;
    }
    .modal{
      width: min(520px, calc(100vw - 24px));
      background: linear-gradient(180deg, var(--panel), var(--panel2));
      border: 1px solid var(--line);
      border-radius: 18px;
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .modal .mhdr{
      padding: 12px 14px;
      border-bottom: 1px solid var(--line);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      background: rgba(255,255,255,.03);
    }
    .modal .mhdr .title{ font-weight: 900; letter-spacing:.2px; }
    .modal .mbody{ padding: 14px; }
    .xbtn{
      border: 1px solid var(--line);
      background: rgba(255,255,255,.04);
      color: var(--txt);
      border-radius: 12px;
      padding: 8px 10px;
      cursor:pointer;
      font-weight: 800;
    }

    /* ✅ Heart marker (CustomOverlay HTML) */
    .heart{
      width: 22px;
      height: 22px;
      position: relative;
      transform: rotate(-45deg);
      cursor: pointer;
      /* ✅ shadow 제거 */
      filter: none;
    }
    .heart::before, .heart::after{
      content:"";
      position:absolute;
      width: 22px;
      height: 22px;
      border-radius: 50%;
      border: 2px solid var(--accent);
      background: transparent;
      top: 0;
      left: 0;
    }
    .heart::after{ left: 10px; }
    .heart .sq{
      position:absolute;
      width: 22px;
      height: 22px;
      border: 2px solid var(--accent);
      background: transparent;
      top: 10px;
      left: 10px;
    }

    /* visited -> fill */
    .heart.visited::before, .heart.visited::after{ background: rgba(255,216,74,.95); }
    .heart.visited .sq{ background: rgba(255,216,74,.95); }

    /* high rating -> red fill */
    .heart.high::before, .heart.high::after{ background: rgba(255,77,77,.92); border-color: rgba(255,77,77,.92); }
    .heart.high .sq{ background: rgba(255,77,77,.92); border-color: rgba(255,77,77,.92); }

    /* selected -> filled (keep color), plus thicker outline */
    .heart.sel::before, .heart.sel::after, .heart.sel .sq{
      border-width: 3px;
    }

    /* multi-visit -> bigger */
    .heart.multi{ transform: rotate(-45deg) scale(1.28); }

    /* tiny helper */
    .kbd{ font-family: var(--mono); font-size: 12px; padding: 2px 6px; border:1px solid var(--line); border-radius:8px; color:var(--muted); background: rgba(0,0,0,.2); }
  </style>
</head>

<body>
  <div id="map"></div>

  <!-- Toast -->
  <div id="toast"></div>

  <!-- ✅ Place Remote (draggable) -->
  <div id="placeBar" class="float" style="display:block; width:min(420px, calc(100vw - 24px));">
    <div class="hdr" data-handle>
      <div class="ttl">
        <span class="hl">가게</span>
        <span id="pbCount" class="pill">0</span>
      </div>
      <div class="row">
        <button id="pbPrev" class="btn" title="이전(랜덤)">◀</button>
        <button id="pbNext" class="btn" title="다음(랜덤)">▶</button>
      </div>
    </div>
    <div class="body">
      <div class="col" style="gap:10px;">
        <div>
          <div id="pbName" class="hl" style="font-size:16px; font-weight:900;">선택된 가게 없음</div>
          <div id="pbAddr" class="muted" style="margin-top:4px;">마커를 눌러 가게를 선택해줘.</div>
        </div>

        <div class="row">
          <button id="pbVisits" class="btn">기록</button>
          <button id="pbWrite" class="btn accent">작성</button>
          <button id="pbManage" class="btn" disabled>관리</button>
        </div>

        <div class="row muted" style="font-size:12px;">
          <span class="kbd">드래그</span> 헤더를 잡고 창을 옮길 수 있음
        </div>
      </div>
    </div>
  </div>

  <!-- ✅ Visits Window (always open, no close) -->
  <div id="visitsWin" class="float" style="display:none; width:min(460px, calc(100vw - 24px));">
    <div class="hdr" data-handle>
      <div class="ttl">
        <span>방문 기록</span>
        <span id="vwTag" class="pill">-</span>
      </div>
      <span class="pill" id="vwCount">0</span>
    </div>
    <div class="body">
      <div id="vwHint" class="muted">가게를 선택하면 여기에 방문 기록이 뜸.</div>
      <div id="vwList" class="list" style="margin-top:10px;"></div>
    </div>
  </div>

  <!-- ✅ Editor Window (always open, no close) -->
  <div id="editorWin" class="float" style="display:none; width:min(520px, calc(100vw - 24px));">
    <div class="hdr" data-handle>
      <div class="ttl">
        <span>방문기 작성</span>
        <span id="ewTag" class="pill">-</span>
      </div>
      <span id="ewMode" class="pill">NEW</span>
    </div>
    <div class="body">
      <div id="ewHint" class="muted">가게를 선택한 뒤 작성하면 됨.</div>
      <div class="sp"></div>

      <div class="row">
        <div style="flex:1;">
          <label>방문 날짜</label>
          <input id="visitDate" type="date" />
        </div>
        <div style="width:140px;">
          <label>평점 (1~5)</label>
          <input id="visitRating" type="number" min="1" max="5" step="1" placeholder="예: 4" />
        </div>
      </div>

      <div class="sp"></div>
      <label>방문기 (문서처럼)</label>
      <textarea id="visitNote" placeholder="오늘의 메뉴, 분위기, 재방문 의사, 동행자, 작은 디테일…"></textarea>

      <div class="sp"></div>
      <div class="row">
        <button id="saveVisit" class="btn accent">저장</button>
        <button id="cancelEdit" class="btn" style="display:none;">편집 취소</button>
      </div>
      <div class="muted" style="font-size:12px; margin-top:10px;">
        로그인 상태에서만 저장 가능.
      </div>
    </div>
  </div>

  <!-- ✅ Manage Window (always open, no close) -->
  <div id="manageWin" class="float" style="display:none; width:min(460px, calc(100vw - 24px));">
    <div class="hdr" data-handle>
      <div class="ttl">
        <span>관리</span>
        <span id="mwTag" class="pill">-</span>
      </div>
      <span class="pill" id="mwMine">N/A</span>
    </div>
    <div class="body">
      <div id="mwHint" class="muted">내가 추가한 가게만 수정/삭제 가능.</div>
      <div class="sp"></div>

      <div class="card">
        <div class="top">
          <div style="font-weight:900;">가게 수정</div>
          <div class="meta">PLACE</div>
        </div>
        <div class="sp"></div>
        <label>가게명</label>
        <input id="editPlaceName" placeholder="가게명" />
        <div class="sp"></div>
        <label>주소</label>
        <input id="editPlaceAddr" placeholder="주소" />
        <div class="sp"></div>
        <div class="row">
          <button id="updatePlace" class="btn">수정 저장</button>
          <button id="deletePlace" class="btn danger">가게 삭제</button>
        </div>
      </div>

      <div class="hr"></div>
      <div class="muted" style="font-size:12px;">
        방문 기록 수정/삭제는 “방문 기록” 창에서 본인 기록에 뜨는 버튼으로 처리.
      </div>
    </div>
  </div>

  <!-- Bottom Dock -->
  <div id="dock">
    <input id="searchInput" placeholder="가게명 검색 (예: 을지로, 라멘, 성수…)" />
    <button id="btnAdd" class="btn accent">추가</button>
    <button id="btnAccount" class="btn">계정</button>
    <button id="btnLogin" class="btn">로그인</button>
  </div>

  <!-- Login Overlay -->
  <div id="loginOv" class="overlay">
    <div class="modal">
      <div class="mhdr">
        <div class="title">로그인</div>
        <button class="xbtn" id="closeLogin">닫기</button>
      </div>
      <div class="mbody">
        <label>이메일</label>
        <input id="loginEmail" type="email" placeholder="you@example.com" />
        <div class="sp"></div>
        <label>비밀번호</label>
        <input id="loginPass" type="password" placeholder="••••••••" />
        <div class="sp"></div>
        <div class="row">
          <button id="doLogin" class="btn accent">로그인</button>
          <button id="openSignup" class="btn">회원가입</button>
        </div>
        <div class="muted" style="margin-top:10px; font-size:12px;">(이메일/비번 방식)</div>
      </div>
    </div>
  </div>

  <!-- Signup Overlay -->
  <div id="signupOv" class="overlay">
    <div class="modal">
      <div class="mhdr">
        <div class="title">회원가입</div>
        <button class="xbtn" id="closeSignup">닫기</button>
      </div>
      <div class="mbody">
        <label>닉네임</label>
        <input id="signupNick" placeholder="예: jaewon" />
        <div class="sp"></div>
        <label>이메일</label>
        <input id="signupEmail" type="email" placeholder="you@example.com" />
        <div class="sp"></div>
        <label>비밀번호</label>
        <input id="signupPass" type="password" placeholder="8자 이상 추천" />
        <div class="sp"></div>
        <div class="row">
          <button id="doSignup" class="btn accent">가입</button>
          <button id="backToLogin" class="btn">로그인으로</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Add Place Overlay -->
  <div id="addOv" class="overlay">
    <div class="modal">
      <div class="mhdr">
        <div class="title">가게 추가</div>
        <button class="xbtn" id="closeAdd">닫기</button>
      </div>
      <div class="mbody">
        <div class="muted" style="font-size:12px; margin-bottom:10px;">
          주소는 카카오 지오코더로 좌표를 잡아 마커 찍음.
        </div>
        <label>가게명</label>
        <input id="addName" placeholder="예: ○○식당" />
        <div class="sp"></div>
        <label>주소</label>
        <input id="addAddr" placeholder="예: 서울 강남구 …" />
        <div class="sp"></div>
        <div class="row">
          <button id="btnGeocode" class="btn">후보 찾기</button>
          <button id="btnSavePlace" class="btn accent" disabled>저장</button>
        </div>
        <div class="sp"></div>
        <div id="candBox" class="list"></div>
      </div>
    </div>
  </div>

  <!-- Account Overlay -->
  <div id="acctOv" class="overlay">
    <div class="modal">
      <div class="mhdr">
        <div class="title">계정</div>
        <button class="xbtn" id="closeAcct">닫기</button>
      </div>
      <div class="mbody" id="acctBody">
        <!-- filled by JS -->
      </div>
    </div>
  </div>

  <script>
    // ====== CONFIG ======
    const SUPABASE_URL = "https://tqybsmrmzxnfuwypbazn.supabase.co";
    const SUPABASE_KEY = "sb_publishable_NOdwos9jU0jwL0AzvZrHHg_KSH5f2e1";

    // ====== STATE ======
    const S = {
      sb: null,
      map: null,
      geocoder: null,
      placesSvc: null,

      session: null,
      user: null,
      profile: null,

      places: [],
      placeById: new Map(),
      overlays: new Map(),  // placeId -> CustomOverlay
      selectedPlaceId: null,
      lastRandomPlaceId: null,

      visits: [],
      editingVisitId: null,

      nickCache: new Map(), // userId -> nickname
      flyToken: 0,

      addCandidate: null, // { address, road_address, x, y }
    };

    // ====== UI REFS ======
    const $ = (id) => document.getElementById(id);

    const toastEl = $("toast");
    let toastTimer = null;
    function toast(msg){
      toastEl.textContent = msg;
      toastEl.classList.add("show");
      clearTimeout(toastTimer);
      toastTimer = setTimeout(()=>toastEl.classList.remove("show"), 1400);
    }

    // Overlays
    const loginOv = $("loginOv");
    const signupOv = $("signupOv");
    const addOv = $("addOv");
    const acctOv = $("acctOv");

    function openOv(el){ el.style.display = "flex"; }
    function closeOv(el){ el.style.display = "none"; }

    // Floating windows
    const placeBar = $("placeBar");
    const visitsWin = $("visitsWin");
    const editorWin = $("editorWin");
    const manageWin = $("manageWin");

    // Dock
    const dock = $("dock");

    // ====== DRAGGABLE ======
    function bringToFront(el){
      // bump z-index within safe range
      const base = 30;
      const all = [placeBar, visitsWin, editorWin, manageWin];
      let maxZ = base;
      for (const w of all){
        const z = parseInt(getComputedStyle(w).zIndex || base, 10);
        if (!Number.isNaN(z)) maxZ = Math.max(maxZ, z);
      }
      el.style.zIndex = String(maxZ + 1);
    }

    function ensureOnscreen(el){
      if (!el || el.style.display === "none") return;
      const r = el.getBoundingClientRect();
      const pad = 8;

      const dockR = dock.getBoundingClientRect();
      const maxX = window.innerWidth - r.width - pad;
      const maxY = window.innerHeight - r.height - pad;

      let x = r.left, y = r.top;

      if (x < pad) x = pad;
      if (x > maxX) x = Math.max(pad, maxX);

      // keep above dock area
      const dockTop = dockR.top - pad;
      if (y + r.height > dockTop) y = Math.max(pad, dockTop - r.height);

      if (y < pad) y = pad;

      el.style.left = x + "px";
      el.style.top  = y + "px";
    }

    function randomPositionNoDock(el){
      const pad = 10;
      const r = el.getBoundingClientRect();
      const dockR = dock.getBoundingClientRect();

      const maxX = Math.max(pad, window.innerWidth - r.width - pad);
      const maxY = Math.max(pad, dockR.top - r.height - pad);

      const x = Math.floor(pad + Math.random() * Math.max(1, (maxX - pad)));
      const y = Math.floor(pad + Math.random() * Math.max(1, (maxY - pad)));

      el.style.left = x + "px";
      el.style.top = y + "px";
    }

    function makeDraggable(win){
      const handle = win.querySelector("[data-handle]");
      if (!handle) return;

      let dragging = false;
      let startX=0, startY=0, startL=0, startT=0;

      handle.addEventListener("pointerdown", (e)=>{
        // 버튼/인풋 위에서는 드래그 시작 금지
        const tag = (e.target && e.target.tagName || "").toLowerCase();
        if (["button","input","textarea","select","a","label"].includes(tag)) return;

        dragging = true;
        bringToFront(win);

        const r = win.getBoundingClientRect();
        startX = e.clientX; startY = e.clientY;
        startL = r.left; startT = r.top;

        handle.setPointerCapture(e.pointerId);
        e.preventDefault();
      });

      handle.addEventListener("pointermove", (e)=>{
        if (!dragging) return;
        const dx = e.clientX - startX;
        const dy = e.clientY - startY;

        win.style.left = (startL + dx) + "px";
        win.style.top  = (startT + dy) + "px";
      });

      handle.addEventListener("pointerup", (e)=>{
        if (!dragging) return;
        dragging = false;
        ensureOnscreen(win);
      });

      // click anywhere bring front
      win.addEventListener("pointerdown", ()=> bringToFront(win), {capture:true});
    }

    // ====== MAP / MARKERS ======
    function heartHTML(classes=""){
      // rotate trick: heart made of 2 circles + square
      return `<div class="heart ${classes}"><div class="sq"></div></div>`;
    }

    function markerClassesFor(place){
      const isSel = (S.selectedPlaceId === place.id);
      const vCount = place.visit_count || 0;
      const avg = place.avg_rating ?? null;

      let c = [];
      // 방문 기록 존재
      if (vCount > 0) c.push("visited");
      // 평점 4+ red
      if (avg !== null && avg >= 4) c.push("high");
      // 여러 번 방문
      if (vCount >= 2) c.push("multi");
      // 선택 -> 두꺼운 테두리 + filled 느낌(이미 visited/high에 의해 fill됨, 없으면 테두리만)
      if (isSel) c.push("sel");

      return c.join(" ");
    }

    function upsertOverlay(place){
      const pos = new kakao.maps.LatLng(place.lat, place.lng);
      const content = heartHTML(markerClassesFor(place));

      if (S.overlays.has(place.id)){
        const ov = S.overlays.get(place.id);
        ov.setPosition(pos);
        // content 교체
        ov.setContent(content);
        return;
      }

      const ov = new kakao.maps.CustomOverlay({
        position: pos,
        content,
        clickable: true,
        yAnchor: 1,
        zIndex: 10
      });

      ov.setMap(S.map);
      S.overlays.set(place.id, ov);

      // click binding: CustomOverlay content is DOM after setMap. Use event delegation via map container.
      // We'll bind by listening click on map container and match overlay elements.
    }

    function rebuildAllOverlays(){
      // remove old
      for (const ov of S.overlays.values()) ov.setMap(null);
      S.overlays.clear();

      for (const p of S.places) upsertOverlay(p);

      // after rebuild, wire overlay clicks by scanning DOM
      wireOverlayClicks();
    }

    function wireOverlayClicks(){
      const mapEl = document.getElementById("map");
      // prevent duplicate binding: remove previous by using one handler stored
      if (mapEl.__ovClickBound) return;
      mapEl.__ovClickBound = true;

      mapEl.addEventListener("click", (e)=>{
        const t = e.target;
        if (!t) return;

        // heart or its children
        const heart = t.classList?.contains("heart") ? t : t.closest?.(".heart");
        if (!heart) return;

        // find which overlay: we don't have id in DOM, so embed data-placeid in content
        // -> Instead: rewrite content with data attribute.
      });
    }

    // We'll override upsertOverlay to include data-placeid and then click works.
    function upsertOverlay(place){
      const pos = new kakao.maps.LatLng(place.lat, place.lng);
      const classes = markerClassesFor(place);
      const content = `<div class="heart ${classes}" data-placeid="${place.id}"><div class="sq"></div></div>`;

      if (S.overlays.has(place.id)){
        const ov = S.overlays.get(place.id);
        ov.setPosition(pos);
        ov.setContent(content);
        return;
      }

      const ov = new kakao.maps.CustomOverlay({
        position: pos,
        content,
        clickable: true,
        yAnchor: 1,
        zIndex: 10
      });
      ov.setMap(S.map);
      S.overlays.set(place.id, ov);
    }

    function refreshOverlayStyles(){
      for (const p of S.places){
        const ov = S.overlays.get(p.id);
        if (!ov) continue;
        const classes = markerClassesFor(p);
        const content = `<div class="heart ${classes}" data-placeid="${p.id}"><div class="sq"></div></div>`;
        ov.setContent(content);
      }
    }

    // ✅ Smooth flyTo: manual RAF 제거, Kakao setLevel animate + (가능하면) jump 사용
    const wait = (ms)=> new Promise(r=>setTimeout(r, ms));

    async function flyToPlace(place){
      if (!S.map) return;
      const token = ++S.flyToken;

      const target = new kakao.maps.LatLng(place.lat, place.lng);
      const startLevel = S.map.getLevel();

      // 멀수록 조금 더 줌아웃
      const center = S.map.getCenter();
      const dist = haversine(center.getLat(), center.getLng(), place.lat, place.lng);
      const outBoost = dist > 6000 ? 3 : (dist > 2500 ? 2 : 1);
      const outLevel = clamp(startLevel + outBoost, 1, 14);

      // zoom out
      S.map.setLevel(outLevel, { animate: { duration: 420 } }); // 공식 문서 옵션
      await wait(430);
      if (token !== S.flyToken) return;

      // move
      if (typeof S.map.jump === "function"){
        S.map.jump(target, outLevel, { animate: { duration: 900 } });
        await wait(920);
      } else {
        // fallback: zoom out 했으니 panTo가 멀리도 애니메이션이 걸릴 확률이 높음
        S.map.panTo(target);
        await wait(700);
      }
      if (token !== S.flyToken) return;

      // zoom in
      S.map.setLevel(startLevel, { animate: { duration: 520 } });
      await wait(540);
    }

    function panToPlace(place){
      if (!S.map) return;
      const target = new kakao.maps.LatLng(place.lat, place.lng);
      S.map.panTo(target);
    }

    function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }

    function haversine(lat1, lon1, lat2, lon2){
      const R = 6371000;
      const toRad = (d)=> d*Math.PI/180;
      const dLat = toRad(lat2-lat1);
      const dLon = toRad(lon2-lon1);
      const A = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
      const C = 2*Math.atan2(Math.sqrt(A), Math.sqrt(1-A));
      return R*C;
    }

    // ====== SUPABASE ======
    function isLoggedIn(){ return !!S.user; }

    async function bootSupabase(){
      S.sb = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);
      const { data } = await S.sb.auth.getSession();
      S.session = data.session;
      S.user = data.session?.user ?? null;

      // listen auth changes
      S.sb.auth.onAuthStateChange(async (_event, session)=>{
        S.session = session;
        S.user = session?.user ?? null;
        await loadMyProfile();
        renderDockAuth();
        await refreshPlaces();     // 로그인/로그아웃 후 UI 동기화
        await refreshSelectedPanels();
      });

      await loadMyProfile();
      renderDockAuth();
    }

    async function loadMyProfile(){
      S.profile = null;
      if (!S.user) return;

      const { data, error } = await S.sb
        .from("profiles")
        .select("id, nickname")
        .eq("id", S.user.id)
        .maybeSingle();

      if (!error && data){
        S.profile = data;
        S.nickCache.set(data.id, data.nickname || "(no nick)");
      }
    }

    function renderDockAuth(){
      const btnLogin = $("btnLogin");
      const btnAccount = $("btnAccount");

      if (S.user){
        btnLogin.textContent = "로그아웃";
      } else {
        btnLogin.textContent = "로그인";
      }
      btnAccount.disabled = false;
    }

    // ====== DATA LOAD ======
    async function refreshPlaces(){
      if (!S.sb) return;

      // places + derived stats (visit_count, avg_rating)
      // NOTE: 이 부분은 DB에 view/rpc가 없는 상태를 고려해서 2번 조회로 계산
      const { data: places, error } = await S.sb
        .from("places")
        .select("id, name, address, lat, lng, created_by, created_at")
        .order("created_at", { ascending:false });

      if (error){
        toast("places 로딩 실패");
        console.error(error);
        return;
      }

      // visit stats
      const { data: stats, error: e2 } = await S.sb
        .from("visits")
        .select("place_id, rating");

      let statMap = new Map();
      if (!e2 && Array.isArray(stats)){
        for (const v of stats){
          if (!statMap.has(v.place_id)) statMap.set(v.place_id, { count:0, sum:0, n:0 });
          const s = statMap.get(v.place_id);
          s.count += 1;
          if (typeof v.rating === "number"){
            s.sum += v.rating; s.n += 1;
          }
        }
      }

      S.places = (places || []).map(p=>{
        const st = statMap.get(p.id);
        const count = st?.count ?? 0;
        const avg = st && st.n > 0 ? (st.sum / st.n) : null;
        return { ...p, visit_count: count, avg_rating: avg };
      });

      S.placeById.clear();
      for (const p of S.places) S.placeById.set(p.id, p);

      $("pbCount").textContent = String(S.places.length);

      rebuildAllOverlays();
      bindOverlayClicksOnce();
      refreshOverlayStyles();

      // keep selection valid
      if (S.selectedPlaceId && !S.placeById.has(S.selectedPlaceId)){
        S.selectedPlaceId = null;
      }

      renderPlaceBar();
    }

    function bindOverlayClicksOnce(){
      const mapEl = document.getElementById("map");
      if (mapEl.__heartBound) return;
      mapEl.__heartBound = true;

      mapEl.addEventListener("click", async (e)=>{
        const target = e.target;
        const heart = target?.closest?.(".heart");
        if (!heart) return;

        const pid = heart.getAttribute("data-placeid");
        if (!pid) return;

        const place = S.placeById.get(pid);
        if (!place) return;

        // marker click: panTo (덜 과격하게)
        selectPlace(pid, { focus: "pan" });
      }, true);
    }

    async function refreshVisits(placeId){
      if (!S.sb || !placeId) return;

      const { data, error } = await S.sb
        .from("visits")
        .select("id, place_id, user_id, visit_date, rating, note, created_at")
        .eq("place_id", placeId)
        .order("visit_date", { ascending:false })
        .order("created_at", { ascending:false });

      if (error){
        console.error(error);
        toast("visits 로딩 실패");
        return;
      }

      S.visits = data || [];
      await hydrateNicknames(S.visits.map(v=>v.user_id));
    }

    async function hydrateNicknames(userIds){
      if (!S.sb) return;
      const uniq = [...new Set(userIds.filter(Boolean))].filter(id => !S.nickCache.has(id));
      if (uniq.length === 0) return;

      const { data, error } = await S.sb
        .from("profiles")
        .select("id, nickname")
        .in("id", uniq);

      if (!error && data){
        for (const p of data){
          S.nickCache.set(p.id, p.nickname || "(no nick)");
        }
      }
    }

    function nickOf(uid){
      if (!uid) return "(unknown)";
      if (S.nickCache.has(uid)) return S.nickCache.get(uid);
      // fallback: email local-part
      return uid.slice(0,6);
    }

    // ====== SELECTION & PANELS ======
    function currentPlace(){
      return S.selectedPlaceId ? S.placeById.get(S.selectedPlaceId) : null;
    }

    async function selectPlace(placeId, { focus="none" } = {}){
      S.selectedPlaceId = placeId;
      const place = currentPlace();

      renderPlaceBar();
      refreshOverlayStyles();

      if (place){
        // focus
        if (focus === "fly") flyToPlace(place);
        if (focus === "pan") panToPlace(place);
      }

      await refreshSelectedPanels();
    }

    async function refreshSelectedPanels(){
      const place = currentPlace();

      // tags
      $("vwTag").textContent = place ? "PLACE" : "-";
      $("ewTag").textContent = place ? "PLACE" : "-";
      $("mwTag").textContent = place ? "PLACE" : "-";

      // Manage fields
      if (!place){
        $("mwHint").textContent = "가게를 선택하면 관리 정보가 뜸.";
        $("mwMine").textContent = "N/A";
        $("editPlaceName").value = "";
        $("editPlaceAddr").value = "";
        $("updatePlace").disabled = true;
        $("deletePlace").disabled = true;
      } else {
        const mine = (S.user && place.created_by === S.user.id);
        $("mwMine").textContent = mine ? "MINE" : "PUBLIC";
        $("mwHint").textContent = mine ? "내 가게: 수정/삭제 가능" : "공유 가게: 수정/삭제 불가";
        $("editPlaceName").value = place.name || "";
        $("editPlaceAddr").value = place.address || "";
        $("updatePlace").disabled = !mine;
        $("deletePlace").disabled = !mine;
      }

      // Visits
      if (!place){
        $("vwHint").style.display = "block";
        $("vwHint").textContent = "가게를 선택하면 여기에 방문 기록이 뜸.";
        $("vwList").innerHTML = "";
        $("vwCount").textContent = "0";
      } else {
        await refreshVisits(place.id);
        renderVisitsList();
      }

      // Editor hint
      if (!place){
        $("ewHint").textContent = "가게를 선택한 뒤 작성하면 됨.";
        $("saveVisit").disabled = true;
      } else {
        $("ewHint").innerHTML = `선택: <span class="hl">${escapeHtml(place.name || "")}</span> (로그인 시 저장 가능)`;
        $("saveVisit").disabled = !isLoggedIn();
      }
    }

    function renderPlaceBar(){
      const place = currentPlace();
      if (!place){
        $("pbName").textContent = "선택된 가게 없음";
        $("pbAddr").textContent = "마커를 눌러 가게를 선택해줘.";
        $("pbManage").disabled = true;
        $("pbPrev").disabled = S.places.length < 2;
        $("pbNext").disabled = S.places.length < 2;
        return;
      }

      $("pbName").textContent = place.name || "(no name)";
      $("pbAddr").textContent = place.address || "(no address)";

      const mine = S.user && place.created_by === S.user.id;
      $("pbManage").disabled = !mine;

      $("pbPrev").disabled = S.places.length < 2;
      $("pbNext").disabled = S.places.length < 2;
    }

    function renderVisitsList(){
      const place = currentPlace();
      if (!place) return;

      $("vwHint").style.display = "none";
      $("vwCount").textContent = String(S.visits.length);

      if (S.visits.length === 0){
        $("vwList").innerHTML = `<div class="muted">아직 방문 기록이 없음. 작성 창에서 첫 기록을 남겨줘.</div>`;
        return;
      }

      const me = S.user?.id ?? null;

      $("vwList").innerHTML = S.visits.map(v=>{
        const nick = nickOf(v.user_id);
        const date = v.visit_date || (v.created_at ? v.created_at.slice(0,10) : "");
        const rating = (typeof v.rating === "number") ? `⭐ ${v.rating}` : "⭐ -";
        const mine = (me && v.user_id === me);

        return `
          <div class="card">
            <div class="top">
              <div style="display:flex; gap:10px; align-items:baseline;">
                <div class="hl">${escapeHtml(nick)}</div>
                <div class="meta">${escapeHtml(date)} · ${escapeHtml(rating)}</div>
              </div>
              <div class="mini-actions">
                ${mine ? `<button class="mini" data-act="edit" data-id="${v.id}">EDIT</button>` : ""}
                ${mine ? `<button class="mini" data-act="del" data-id="${v.id}">DEL</button>` : ""}
              </div>
            </div>
            <div class="sp"></div>
            <div class="note">${escapeHtml(v.note || "")}</div>
          </div>
        `;
      }).join("");

      // bind actions
      $("vwList").querySelectorAll("button.mini").forEach(btn=>{
        btn.addEventListener("click", async ()=>{
          const act = btn.getAttribute("data-act");
          const id = btn.getAttribute("data-id");
          if (!act || !id) return;

          if (act === "edit"){
            startEditVisit(id);
            bringToFront(editorWin);
          }
          if (act === "del"){
            await deleteVisit(id);
          }
        });
      });
    }

    function startEditVisit(visitId){
      const v = S.visits.find(x=>x.id === visitId);
      if (!v) return;

      S.editingVisitId = v.id;
      $("ewMode").textContent = "EDIT";
      $("cancelEdit").style.display = "inline-block";

      $("visitDate").value = v.visit_date || "";
      $("visitRating").value = (typeof v.rating === "number") ? String(v.rating) : "";
      $("visitNote").value = v.note || "";
    }

    function clearEditor(){
      S.editingVisitId = null;
      $("ewMode").textContent = "NEW";
      $("cancelEdit").style.display = "none";

      // default date today
      const today = new Date();
      const yyyy = today.getFullYear();
      const mm = String(today.getMonth()+1).padStart(2,"0");
      const dd = String(today.getDate()).padStart(2,"0");
      $("visitDate").value = `${yyyy}-${mm}-${dd}`;
      $("visitRating").value = "";
      $("visitNote").value = "";
    }

    // ====== ACTIONS ======
    async function saveVisit(){
      const place = currentPlace();
      if (!place) return toast("가게를 먼저 선택");
      if (!isLoggedIn()) return toast("로그인 필요");

      const visit_date = $("visitDate").value || null;
      let rating = $("visitRating").value.trim();
      rating = rating ? Number(rating) : null;
      if (rating !== null && (!Number.isFinite(rating) || rating < 1 || rating > 5)){
        return toast("평점은 1~5");
      }
      const note = $("visitNote").value || "";

      const payload = {
        place_id: place.id,
        user_id: S.user.id,
        visit_date,
        rating,
        note
      };

      if (S.editingVisitId){
        const { error } = await S.sb.from("visits").update(payload).eq("id", S.editingVisitId);
        if (error){ console.error(error); return toast("수정 실패"); }
        toast("수정 완료");
      } else {
        const { error } = await S.sb.from("visits").insert(payload);
        if (error){ console.error(error); return toast("저장 실패"); }
        toast("저장 완료");
      }

      clearEditor();
      await refreshPlaces();              // stats 갱신
      await refreshSelectedPanels();      // visits 갱신
    }

    async function deleteVisit(visitId){
      if (!isLoggedIn()) return toast("로그인 필요");

      const ok = confirm("이 방문 기록을 삭제할까?");
      if (!ok) return;

      const { error } = await S.sb.from("visits").delete().eq("id", visitId);
      if (error){ console.error(error); return toast("삭제 실패"); }

      toast("삭제 완료");
      clearEditor();
      await refreshPlaces();
      await refreshSelectedPanels();
    }

    async function updatePlace(){
      const place = currentPlace();
      if (!place) return toast("가게 선택 필요");
      if (!isLoggedIn()) return toast("로그인 필요");
      if (place.created_by !== S.user.id) return toast("내 가게만 수정 가능");

      const name = $("editPlaceName").value.trim();
      const address = $("editPlaceAddr").value.trim();
      if (!name || !address) return toast("가게명/주소 필요");

      const { error } = await S.sb.from("places").update({ name, address }).eq("id", place.id);
      if (error){ console.error(error); return toast("수정 실패"); }

      toast("가게 수정 완료");
      await refreshPlaces();
      // selection 유지
      if (S.selectedPlaceId) await selectPlace(S.selectedPlaceId, { focus:"none" });
    }

    async function deletePlace(){
      const place = currentPlace();
      if (!place) return toast("가게 선택 필요");
      if (!isLoggedIn()) return toast("로그인 필요");
      if (place.created_by !== S.user.id) return toast("내 가게만 삭제 가능");

      const ok = confirm("가게를 삭제할까? (방문 기록이 있으면 정책에 따라 실패할 수 있음)");
      if (!ok) return;

      const { error } = await S.sb.from("places").delete().eq("id", place.id);
      if (error){ console.error(error); return toast("삭제 실패(방문 기록 존재 가능)"); }

      toast("가게 삭제 완료");
      S.selectedPlaceId = null;
      await refreshPlaces();
      await refreshSelectedPanels();
    }

    // ====== RANDOM NEXT (exclude previous) ======
    function pickRandomNext(){
      if (S.places.length < 2) return null;
      const current = S.selectedPlaceId;
      const exclude = new Set([current, S.lastRandomPlaceId].filter(Boolean));

      let candidates = S.places.filter(p => !exclude.has(p.id));
      if (candidates.length === 0){
        candidates = S.places.filter(p => p.id !== current);
      }
      const next = candidates[Math.floor(Math.random()*candidates.length)];
      return next || null;
    }

    async function goRandomNext(){
      const next = pickRandomNext();
      if (!next) return;
      S.lastRandomPlaceId = S.selectedPlaceId;
      await selectPlace(next.id, { focus:"fly" }); // ✅ fly = zoom-out/in smooth 버전
    }

    // ====== SEARCH ======
    function applySearch(q){
      q = (q||"").trim().toLowerCase();
      if (!q){
        // show all overlays
        for (const p of S.places) upsertOverlay(p);
        refreshOverlayStyles();
        return;
      }
      // simple: dim by rebuilding content with different border? -> keep minimal: just toast count
      const hits = S.places.filter(p =>
        (p.name||"").toLowerCase().includes(q) ||
        (p.address||"").toLowerCase().includes(q)
      );
      toast(`검색: ${hits.length}개`);
    }

    // ====== ADD PLACE FLOW ======
    async function geocodeCandidates(){
      const name = $("addName").value.trim();
      const addr = $("addAddr").value.trim();
      if (!name) return toast("가게명 필요");
      if (!addr) return toast("주소 필요");

      if (!S.geocoder) return toast("지오코더 준비 안됨");

      $("candBox").innerHTML = `<div class="muted">검색중…</div>`;
      $("btnSavePlace").disabled = true;
      S.addCandidate = null;

      // addressSearch
      S.geocoder.addressSearch(addr, (result, status)=>{
        if (status !== kakao.maps.services.Status.OK || !result || result.length === 0){
          $("candBox").innerHTML = `<div class="muted">후보 없음. 주소를 더 정확히 입력해줘.</div>`;
          return;
        }

        const list = result.slice(0, 6).map((r, idx)=>{
          const label = r.road_address?.address_name || r.address?.address_name || "(unknown)";
          const x = r.x, y = r.y;
          return `
            <button class="btn" style="text-align:left; width:100%;" data-x="${x}" data-y="${y}" data-label="${escapeHtml(label)}">
              <div style="font-weight:900; color:var(--accent);">후보 ${idx+1}</div>
              <div class="muted" style="font-size:12px;">${escapeHtml(label)}</div>
              <div class="meta">(${Number(y).toFixed(6)}, ${Number(x).toFixed(6)})</div>
            </button>
          `;
        }).join("");

        $("candBox").innerHTML = `<div class="list">${list}</div>`;

        // ✅ 클릭 안 먹는 버그 방지: 버튼에 직접 바인딩
        $("candBox").querySelectorAll("button.btn").forEach(btn=>{
          btn.addEventListener("click", ()=>{
            const x = btn.getAttribute("data-x");
            const y = btn.getAttribute("data-y");
            const label = btn.getAttribute("data-label");
            S.addCandidate = { x:Number(x), y:Number(y), label };
            toast("후보 선택됨");
            $("btnSavePlace").disabled = false;
          });
        });
      });
    }

    function normalizeKey(name, addr){
      return (name||"").trim().toLowerCase().replace(/\s+/g," ") + " | " + (addr||"").trim().toLowerCase().replace(/\s+/g," ");
    }

    async function savePlace(){
      if (!isLoggedIn()) return toast("로그인 필요");
      const name = $("addName").value.trim();
      const addr = $("addAddr").value.trim();
      if (!name || !addr) return toast("가게명/주소 필요");
      if (!S.addCandidate) return toast("후보를 먼저 선택");

      // client-side duplicate check
      const key = normalizeKey(name, addr);
      const exists = S.places.some(p => normalizeKey(p.name, p.address) === key);
      if (exists){
        $("btnSavePlace").disabled = true;
        return toast("이미 등록된 가게");
      }

      const lat = S.addCandidate.y;
      const lng = S.addCandidate.x;

      const payload = { name, address: addr, lat, lng, created_by: S.user.id };

      const { error } = await S.sb.from("places").insert(payload);
      if (error){
        console.error(error);
        // unique constraint가 있으면 여기로 떨어짐
        if (String(error.message||"").toLowerCase().includes("duplicate") || String(error.code||"") === "23505"){
          return toast("이미 등록된 가게");
        }
        return toast("추가 실패");
      }

      toast("가게 추가 완료");
      closeOv(addOv);
      $("addName").value = "";
      $("addAddr").value = "";
      $("candBox").innerHTML = "";
      $("btnSavePlace").disabled = true;
      S.addCandidate = null;

      await refreshPlaces();

      // 새로 추가한 가게를 선택(가장 최근 created_at 기준으로 first)
      const newest = S.places[0];
      if (newest) await selectPlace(newest.id, { focus:"fly" });
    }

    // ====== ACCOUNT ======
    async function openAccount(){
      const box = $("acctBody");
      if (!S.user){
        box.innerHTML = `
          <div class="muted">로그인하면 계정 정보/통계가 뜸.</div>
          <div class="sp"></div>
          <button class="btn accent" id="acctGoLogin">로그인</button>
        `;
        box.querySelector("#acctGoLogin").addEventListener("click", ()=>{
          closeOv(acctOv);
          openOv(loginOv);
        });
        openOv(acctOv);
        return;
      }

      // stats
      const myId = S.user.id;

      const myPlaces = S.places.filter(p => p.created_by === myId).length;

      const { data: myVisits, error } = await S.sb
        .from("visits")
        .select("id")
        .eq("user_id", myId);

      const vCount = (!error && myVisits) ? myVisits.length : 0;

      const nick = S.profile?.nickname || "(no nick)";
      box.innerHTML = `
        <div class="card">
          <div class="top">
            <div style="font-weight:900;">현재 로그인</div>
            <div class="meta">AUTH</div>
          </div>
          <div class="sp"></div>
          <div><span class="muted">닉네임</span> · <span class="hl">${escapeHtml(nick)}</span></div>
          <div class="muted" style="font-size:12px; margin-top:6px;">${escapeHtml(S.user.email || "")}</div>
        </div>

        <div class="sp"></div>

        <div class="card">
          <div class="top">
            <div style="font-weight:900;">통계</div>
            <div class="meta">STATS</div>
          </div>
          <div class="sp"></div>
          <div class="row">
            <span class="pill">내가 추가한 가게: <b>${myPlaces}</b></span>
            <span class="pill">내 방문 기록: <b>${vCount}</b></span>
          </div>
        </div>

        <div class="sp"></div>

        <div class="row">
          <button class="btn danger" id="acctLogout">로그아웃</button>
        </div>
      `;

      box.querySelector("#acctLogout").addEventListener("click", async ()=>{
        await S.sb.auth.signOut();
        toast("로그아웃");
        closeOv(acctOv);
      });

      openOv(acctOv);
    }

    // ====== AUTH ======
    async function doLogin(){
      const email = $("loginEmail").value.trim();
      const password = $("loginPass").value;
      if (!email || !password) return toast("이메일/비번 필요");

      const { error } = await S.sb.auth.signInWithPassword({ email, password });
      if (error){
        console.error(error);
        return toast("로그인 실패");
      }
      toast("로그인");
      closeOv(loginOv);
      clearEditor();
      $("saveVisit").disabled = false;
    }

    async function doSignup(){
      const nickname = $("signupNick").value.trim();
      const email = $("signupEmail").value.trim();
      const password = $("signupPass").value;

      if (!nickname) return toast("닉네임 필요");
      if (!email || !password) return toast("이메일/비번 필요");

      const { data, error } = await S.sb.auth.signUp({ email, password });
      if (error){
        console.error(error);
        return toast("회원가입 실패");
      }

      // profile upsert
      const uid = data.user?.id;
      if (uid){
        const { error: e2 } = await S.sb.from("profiles").upsert({ id: uid, nickname });
        if (e2) console.error(e2);
      }

      toast("가입 완료");
      closeOv(signupOv);
      // 바로 로그인 화면으로
      openOv(loginOv);
    }

    // ====== INIT ======
    function positionPlaceBarDefault(){
      const dockR = dock.getBoundingClientRect();
      const w = placeBar.getBoundingClientRect().width;
      const x = Math.floor((window.innerWidth - w)/2);
      const y = Math.floor(dockR.top - placeBar.getBoundingClientRect().height - 10);
      placeBar.style.left = Math.max(10, x) + "px";
      placeBar.style.top  = Math.max(10, y) + "px";
      ensureOnscreen(placeBar);
    }

    function openAllWindowsAtStart(){
      // ✅ 첫 화면부터 창 전부 띄움 (닫기 버튼 없음)
      visitsWin.style.display = "block";
      editorWin.style.display = "block";
      manageWin.style.display = "block";

      positionPlaceBarDefault();

      // 랜덤 배치 (검색바 가리지 않게)
      randomPositionNoDock(visitsWin);
      randomPositionNoDock(editorWin);
      randomPositionNoDock(manageWin);

      // ensure
      ensureOnscreen(visitsWin);
      ensureOnscreen(editorWin);
      ensureOnscreen(manageWin);

      // bring order
      bringToFront(placeBar);
      bringToFront(visitsWin);
      bringToFront(editorWin);
      bringToFront(manageWin);

      clearEditor();
    }

    async function bootMap(){
      // Kakao SDK ready
      const mapContainer = document.getElementById("map");
      const center = new kakao.maps.LatLng(37.5665, 126.9780); // Seoul
      const mapOption = { center, level: 7 };
      S.map = new kakao.maps.Map(mapContainer, mapOption);

      S.geocoder = new kakao.maps.services.Geocoder();
      S.placesSvc = new kakao.maps.services.Places();

      // click on blank map: keep selection (no action)
      // (원하면 selection clear도 가능)

      await refreshPlaces();

      // default pick first
      if (!S.selectedPlaceId && S.places.length > 0){
        await selectPlace(S.places[0].id, { focus:"none" });
      } else {
        await refreshSelectedPanels();
      }
    }

    function escapeHtml(s){
      return String(s ?? "")
        .replaceAll("&","&amp;")
        .replaceAll("<","&lt;")
        .replaceAll(">","&gt;")
        .replaceAll('"',"&quot;")
        .replaceAll("'","&#039;");
    }

    document.addEventListener("DOMContentLoaded", async ()=>{
      // draggable setup
      makeDraggable(placeBar);
      makeDraggable(visitsWin);
      makeDraggable(editorWin);
      makeDraggable(manageWin);

      openAllWindowsAtStart();

      // dock buttons
      $("btnLogin").addEventListener("click", async ()=>{
        if (S.user){
          await S.sb.auth.signOut();
          toast("로그아웃");
          return;
        }
        openOv(loginOv);
      });

      $("btnAccount").addEventListener("click", openAccount);

      $("btnAdd").addEventListener("click", ()=>{
        if (!isLoggedIn()){
          toast("로그인 후 추가 가능");
          openOv(loginOv);
          return;
        }
        openOv(addOv);
      });

      $("searchInput").addEventListener("input", (e)=> applySearch(e.target.value));

      // place bar actions
      $("pbPrev").addEventListener("click", goRandomNext);
      $("pbNext").addEventListener("click", goRandomNext);

      $("pbVisits").addEventListener("click", ()=>{
        bringToFront(visitsWin);
        toast("방문 기록 창");
      });
      $("pbWrite").addEventListener("click", ()=>{
        bringToFront(editorWin);
        toast("작성 창");
      });
      $("pbManage").addEventListener("click", ()=>{
        bringToFront(manageWin);
        toast("관리 창");
      });

      // editor
      $("saveVisit").addEventListener("click", saveVisit);
      $("cancelEdit").addEventListener("click", ()=>{
        clearEditor();
        toast("편집 취소");
      });

      // manage
      $("updatePlace").addEventListener("click", updatePlace);
      $("deletePlace").addEventListener("click", deletePlace);

      // login/signup modals
      $("closeLogin").addEventListener("click", ()=>closeOv(loginOv));
      $("openSignup").addEventListener("click", ()=>{
        closeOv(loginOv);
        openOv(signupOv);
      });
      $("doLogin").addEventListener("click", doLogin);

      $("closeSignup").addEventListener("click", ()=>closeOv(signupOv));
      $("backToLogin").addEventListener("click", ()=>{
        closeOv(signupOv);
        openOv(loginOv);
      });
      $("doSignup").addEventListener("click", doSignup);

      // add place
      $("closeAdd").addEventListener("click", ()=>closeOv(addOv));
      $("btnGeocode").addEventListener("click", geocodeCandidates);
      $("btnSavePlace").addEventListener("click", savePlace);

      // account
      $("closeAcct").addEventListener("click", ()=>closeOv(acctOv));

      // resize: keep all windows onscreen (오버랩 허용, 그냥 화면 안으로만)
      window.addEventListener("resize", ()=>{
        positionPlaceBarDefault();
        ensureOnscreen(visitsWin);
        ensureOnscreen(editorWin);
        ensureOnscreen(manageWin);
      });

      // boot supabase now (map waits for kakao anyway)
      await bootSupabase();
    });

    window.addEventListener("load", async ()=>{
      // Kakao script loaded after defer, so load event is safe
      try{
        await bootMap();
      } catch (e){
        console.error(e);
        toast("지도 초기화 실패");
      }
    });
  </script>
</body>
</html>
